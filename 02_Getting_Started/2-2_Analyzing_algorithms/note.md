## 2.2 アルゴリズムの解析

アルゴリズムの解析 = そのアルゴリズムが必要とするリソースを予測すること  
リソースとしてもっともよく使われるのは計算時間 

解析の前に、アルゴリズムの実装技術のモデルが必要  
→ ランダムアクセス機械（random-access machine、RAM）モデル  
RAMモデルにおいては、命令は並列せずに1つずつ順番に実行される

RAMモデルとしてどのような命令をもつかは、現実のコンピュータの設計がどうなっているかがガイドになる
- 算術（四則演算、剰余、切り上げ切り捨て）、データの移動（ロード、保存、コピー）、制御（条件分岐）
- 各命令には一定の時間がかかる
- データ型は整数と浮動小数点数

現実のコンピュータは上記にない命令も含まれており、そのような命令はRAMモデルにおいてはグレーゾーンとなっている  
例）冪乗を計算する命令
- ほとんどのコンピュータにおいてはビットを左シフトすることは $2^k$ を計算することと同じであるので、 $k$ がワードのビット数以下である限り $2^k$ は一定時間で計算できる
- 本書では $k$ が十分に小さい正の整数である場合に $2^k$ を一定時間の命令として扱う


### 挿入ソートの解析

一般的に、アルゴリズムにかかる時間は入力サイズに比例する  
→ プログラムの実行時間を入力サイズの関数として表す

入力サイズ:
- 分析対象の問題によって変わってくる。ソートであれば配列の要素数、グラフであれば辺と頂点のそれぞれの数など

実行時間:
- プリミティブな操作の数、または実行されるステップの数
- 擬似コードの各業を実行するには一定量の時間が必要であり、各行はそれぞれ異なる実行時間になりうる。 $i$ 行目の実行にかかる時間を $c_i$ とする
- また、ループテストの回数を $t_j$ で表す（普通はループテストの回数はループの中身が実行される回数より1回多い）
- コメントは実行されないので時間はかからない

```
for j = 2 to A.length
	key = A[j]
	// Insert A[j] into the sorted sequence A[1 .. j - 1]
	i = j - 1
	while i > 0 and A[i] > key
		A[i + 1] = A[j]
		i = i - 1
	A[i + 1] = key
```

上の挿入ソートの擬似コードにかかる実行時間は、以下のようになる。

$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5\sum_{j=2}^{n}t_j + c_6\sum_{j=2}^n(t_j-1) + c_7\sum_{j-2}^{n}(t_j-1) + c_8(n-1)
$$

入力サイズだけでなく、どんな入力化によっても実行時間は変わりうる。  
例えば挿入ソートでは、最善のケースは配列がすでにソート済みの場合である。この場合、各 $j$ においてループテストは1回しか発生しないため、 $t_j = 1$ となる。よって $T(n))$ は

$$
\begin{eqnarray*}
T(n) &=& c_1n + c_2(n-1) + c_4(n-1) + c_5 + c_8(n-1) \\
&=& (c_1 + c_2 + c_4 + c_8)n - (c_2 + c_4 + c+5 + c_8)
\end{eqnarray*}
$$

となる。これは $an+b$ と表現できるので、 $n$ についての線形関数である。  

もし配列が逆順（降順）にソートされている場合、最悪のケースとなる。この場合、各 $j$ においてループテストは $j$ 回（配列の先頭の要素から $j - 1$ 番目まで）発生するので $t_j = j$ となる。よって $T(n)$ は

$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) \\
    + c_5\left(\dfrac{n(n+1)}{2}-1\right) 
    + c_6\left(\dfrac{n(n-1)}{2}\right)\\
    + c_7\left(\dfrac{n(n-1)}{2}\right)
    + c_8(n-1)
$$

となる。これは $an^2+bn+c$ と表現できるので、 $n$ についての二次関数である。

### 最悪ケースと平均ケースの解析
上記では最善と最悪の両ケースを見たが、通常は最悪時実行時間にのみフォーカスする。

- 理由1: 最悪時実行時間を知ることでインプットに対する実行時間の上限がわかる
- 理由2: 最悪のケースが頻繁に発生するアルゴリズムが存在する（DBからの検索において検索対象が存在しないときなど）
- 理由3: 平均ケースは最悪ケースと同じくらいの計算量になることが多い

### 増加のオーダー
先の例では解析を簡単にするためにいくつかの単純化を行なってきた。  
さらに単純化するため、最も次数の高い項のみを考慮し、その係数も無視する。  
挿入ソートは最悪時実行時間 $\Theta(n^2)$ をもつと書く。  
通常、あるアルゴリズムが他のアルゴリズムより低い増加のオーダーであるとき、そのアルゴリズムはより効率的であるという。
